#
# Makefile include file to include standard cloudfit tooling for version files for pythonic layers
# Included by other .mk files, do not use directly.
#

ifdef BASE_MOD
EXTRA_MODS_REQUIRED:=$(BASE_MOD)
endif

VERSIONFILE:=$(MODNAME)/_version.py
EXTRA_MODS_REQUIRED_DIRS:=$(patsubst %,$(project_root_dir)/src/%,$(EXTRA_MODS_REQUIRED))
EXTRA_MODS_REQUIRED_VERSIONFILE:=$(foreach D,$(EXTRA_MODS_REQUIRED_DIRS),$(shell echo $(D)/`python3 $(D)/setup.py --name`/_version.py))

# These shell grep commands extract the git_commit variable value that's currently in the _version.py file if one exists
# These variables are empty if no such file exists
GITCOMMIT_IN_FILE:=$(strip $(shell cat .tmp/_full_version.py 2> /dev/null | grep git_commit | grep -E \'[0-9a-f]+\' -o | grep -E -o [0-9a-f]+))
EXTRA_MODS_GITCOMMIT_IN_FILE:=$(foreach versionfile,$(EXTRA_MODS_REQUIRED_VERSIONFILE),$(strip $(shell cat $(versionfile) 2> /dev/null | grep git_commit | grep -E \'[0-9a-f]+\' -o | grep -E -o [0-9a-f]+)))
EXTRA_MODS_GITCOMMIT_IN_FILE_NOTMATCH:=$(filter-out $(GITCOMMIT),$(EXTRA_MODS_GITCOMMIT_IN_FILE))

FULL_VERSION_IN_FILE:=$(strip $(shell cat .tmp/_full_version.py 2> /dev/null | grep __version__ | sed -n "s/__version__ *= *'\(.*\)'/\1/p"))
NEXT_VERSION_IN_FILE:=$(strip $(shell cat .tmp/_next_version.py 2> /dev/null | grep __version__ | sed -n "s/__version__ *= *'\(.*\)'/\1/p"))
EXTRA_MODS_VERSION_IN_FILE:=$(foreach versionfile,$(EXTRA_MODS_REQUIRED_VERSIONFILE),$(strip $(shell cat $(versionfile) 2> /dev/null | grep git_commit | grep -E \'[0-9a-f]+\' -o | grep -E -o [0-9a-f]+)))
EXTRA_MODS_VERSION_IN_FILE_NOTMATCH:=$(filter-out $(VERSION),$(EXTRA_MODS_VERSION_IN_FILE))
EXTRA_MODS_VERSION_IN_FILE_NOTMATCH_NEXT:=$(filter-out $(NEXT_VERSION),$(EXTRA_MODS_VERSION_IN_FILE))

all:

prepcode: $(VERSIONFILE)

version: $(VERSIONFILE)

source-pythonic: $(VERSIONFILE)

install-pythonic: $(VERSIONFILE) $(EXTRA_MODS_REQUIRED_VERSIONFILE)

wheel: $(VERSIONFILE)

common-base: $(VERSIONFILE) $(EXTRA_MODS_REQUIRED_VERSIONFILE)

CLEAN_FILES += $(VERSIONFILE)

# We create two _version.py files, one for the current version, and one for the next release

# This ensures that if the current git commit differs from the one set in the
# version file then the full_version file will be forced to rebuild
ifneq "$(GITCOMMIT)" "$(GITCOMMIT_IN_FILE)"
$(topdir)/.tmp/_full_version.py: forcerebuild
endif

ifneq "$(VERSION)" "$(FULL_VERSION_IN_FILE)"
$(topdir)/.tmp/_full_version.py: forcerebuild
endif

ifneq "$(NEXT_VERSION)" "$(NEXT_VERSION_IN_FILE)"
$(topdir)/.tmp/_next_version.py: forcerebuild
endif

$(topdir)/.tmp/_full_version.py: $(topdir)/.tmp
	@echo "# this file was generated by the $(PROJECT) Makefile" > $(topdir)/.tmp/_full_version.py
	@echo "" >> $(topdir)/.tmp/_full_version.py
	@echo "__version__ = '$(VERSION)'" >> $(topdir)/.tmp/_full_version.py
	@echo "git_commit = '$(GITCOMMIT)'" >> $(topdir)/.tmp/_full_version.py

$(topdir)/.tmp/_next_version.py: $(topdir)/.tmp
	@echo "# this file was generated by the $(PROJECT) Makefile" > $(topdir)/.tmp/_next_version.py
	@echo "" >> $(topdir)/.tmp/_next_version.py
	@echo "__version__ = '$(NEXT_VERSION)'" >> $(topdir)/.tmp/_next_version.py
	@echo "git_commit = '0000000'" >> $(topdir)/.tmp/_next_version.py


ifeq "${BUILD_TAG}" "local"
$(VERSIONFILE): $(topdir)/.tmp/_next_version.py
	cp $< $@
else
$(VERSIONFILE): $(topdir)/.tmp/_full_version.py
	cp $< $@
endif


$(topbuilddir)/dist/$(MODNAME)-$(VERSION_IN_PYTHON).tar.gz: $(MODNAME)/_version.py

# This ensures that if the current git commit differs from the one set in the
# extra mods version files then the extra mods versions will be forced to rebuild
ifneq "$(EXTRA_MODS_GITCOMMIT_IN_FILE_NOTMATCH)" ""
$(EXTRA_MODS_REQUIRED_VERSIONFILE): forcerebuild
endif

ifneq "$(EXTRA_MODS_VERSION_IN_FILE_NOTMATCH)" ""
$(EXTRA_MODS_REQUIRED_VERSIONFILE): forcerebuild
endif


$(EXTRA_MODS_REQUIRED_VERSIONFILE):
	$(MAKE) -C $(dir $@)/.. version
